#!/usr/bin/env bash

# URY Radio Text Controller
# Copyright (C) 2022 - University Radio York
# Author: Michael Grace <michael.grace@ury.org.uk>

set -euo pipefail

default_text="By Students, For Students - University Radio York"
output_device=/dev/null
wait_seconds=10
max_msg_length=64

pid_file=/tmp/radiotext.pid
last_msg_file=/tmp/radiotext.last
messages_file=radiotext.messages
api_base_url=https://ury.org.uk/api/v2
api_key_file=.myradio.key

usage () {
    >&2 echo "$(basename $0) command
    
    Commands:
        - start: start the radiotext daemon
        - stop: stop the radiotext daemon
        - now: view what is currently on radiotext
        - live: follow radiotext updates in real time TODO
    "
    exit 1
}

check_running () {
    [[ -f $pid_file ]] && return
    >&2 echo "daemon not running"
    exit 1
}

split_text_to_length () {
    local full_msg=${@}
    local sub_msg=""

    for word in $full_msg; do
        check_msg="$sub_msg $word"
        if [[ ${#check_msg} -le $max_msg_length ]]; then
            sub_msg=$check_msg
        else
            echo $sub_msg
            sub_msg=$word
        fi
    done

    echo $sub_msg
}

output_text () {
    echo -ne "${@}\f" | tee $output_device $last_msg_file > /dev/null
}

myradio_api_request () {
    local endpoint=$1
    if [[ $(echo $endpoint | grep "?") == "" ]]; then
        endpoint_with_key="$endpoint?api_key=$(cat $api_key_file)"
    else
        endpoint_with_key="$endpoint&api_key=$(cat $api_key_file)"
    fi
    
    # TODO deal with failed auth
    curl "$api_base_url/$endpoint_with_key" 2>/dev/null | jq .payload
}

display_messages () {
    output_text $default_text
    sleep $wait_seconds

    [[ ! -f $messages_file ]] && return
    while read message; do
        output_text $message
        sleep $wait_seconds
    done < $messages_file
}

off_air () {
    myradio_api_request "scheduler/isterm" | jq -r '. | not'
}

now_playing () {
    
    np=$(myradio_api_request "track/nowplaying?allowOffAir=$(off_air)")
    [[ $np == "null" ]] && return

    now_playing_msg="Now Playing:  $(echo $np | jq -r '(.track.title + " - " + .track.artist)')"
    
    while read line; do
        output_text $line
        sleep $wait_seconds
    done < <(split_text_to_length $now_playing_msg)
}

on_air_show () {
    # TODO - what if it's jukebox/off air
    # TODO - next show at 10 to the hour?
    on_air_text="On Air Next: $(myradio_api_request "timeslot/currentandnext?n=1" \
        | jq -r '(.next.title + " with " + .next.presenters)')"

    while read line; do
        output_text $line
        sleep $wait_seconds
    done < <(split_text_to_length $on_air_text)
}

daemon () {
    # TODO 'URY News' on the hour
    while true; do
        display_messages
        now_playing
        on_air_show
    done
}

start_daemon () {
    if [[ -f $pid_file ]]; then
        >&2 echo "daemon already running"
        exit 1
    fi

    touch $last_msg_file

    daemon &
    echo $! > $pid_file
}

stop_daemon () {
    set +e
    kill $(cat $pid_file) > /dev/null 2>&1
    set -e
    rm $pid_file
    output_text $default_text
}

main () {
    [[ $# -ne 1 ]] && usage

    case $1 in
        "start")
            start_daemon
            ;;
        
        "stop")
            check_running
            stop_daemon
            ;;

        "now")
            check_running
            cat $last_msg_file
            ;;

        "live")
            # TODO
            check_running
            cat $last_msg_file
            ;;

        *)
            usage
            ;;
    esac
}

main ${@}
